'''Populate SQLite DB from JSON Dump

This script parses a JSON file generated by the scrapy project in jeppy/scraper
directory. After cleaning the raw data it writes the resulting Clue to the db.

This file should not be imported as a module, it's meant to be run by a user in
one off situations or as part of a taskfile task.
'''

import json

from app import db
from app.models import Clue


def clean_game_entry(raw_game):
    '''Takes in a raw game entry and returns the cleaned list of Clues.'''
    
    # Build a list of string keys representing each category.
    #  J_<NUM>: single jeopardy
    #  DJ_<NUM>: double jeopardy
    #  FJ: final jeopardy
    #  TB: tie break (this is rare)
    cat_keys = []
    for i in range(1, 7):
        cat_keys.extend(["J_" + str(i), "DJ_" + str(i)])
    cat_keys.extend(["FJ", "TB"])

    # Fetch the category names from the raw_game.
    clean_categories = {x: raw_game["category_" + str(x)][0] for x in cat_keys}

    # Build a list of Clues from the raw_game.
    game_id = raw_game["game_id"][0]
    clues = []
    for index, clue_id in enumerate(raw_game["clue_ids"]):
        clean_clue_id = clue_id[5:]
        category = clean_categories[clean_clue_id] if len(
            clean_clue_id) <= 2 else clean_categories[clean_clue_id[:-2]]

        c = Clue(
            game_id,
            clean_clue_id,
            category,
            raw_game["clues"][index],
            raw_game["correct_responses"][index])
        clues.append(c)

    return clues

# TODO: while this works, it's a bit wonky. The first call to rollback() will
# behave as expected, but the call to rollback() in the second try/catch is
# essentially a noop. By the time we enter the second try/catch the clue table
# must be empty, so if we hit the except clause we'll just be rolling back to
# an empty table.
#
# Some ideas:
#  - we could commit the db writes in batches which would leave us with a
#    partially populated db if we encounter and exception
#  - we could add a unique constraint or index at the db level and swallow
#    the exceptions related to inserting an existing record (i'm not sure if
#    this is possible in sqlite)


# Delete all existing records from the clue table.
try:
    num_rows_deleted = db.session.query(Clue).delete()
    db.session.commit()
except Exception as e:
    print(e)
    db.session.rollback()
    exit(1)

try:
    # Load the JSON file into a dictionary.
    with open("../data/dump.json") as infile:
        data = json.load(infile)

    # Clean each game entry in the json file and write it to the db.
    for game_entry in data:
        clean_clues = clean_game_entry(game_entry)
        for c in clean_clues:
            db.session.add(c)
    db.session.commit()
except Exception as e:
    print(e)
    db.session.rollback()
